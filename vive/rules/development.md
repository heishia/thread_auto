## **1\) 기본 규칙**

### **0.0 모듈화(에이전트 친화)**

* 한 파일은 권장 2,000자 이내로 유지하고 초과 시 기능 단위로 분리한다.  
* 의존성은 단방향만 허용한다: `interface → service → domain → adapter(repo)` (순환 의존 금지).  
* 각 폴더는 외부에 노출할 항목만 `index` 또는 `__init__`로 export하고 내부 구현은 숨긴다.  
* 분리 트리거: 변경 이유가 2개 이상이 되거나 수정 범위가 커지면 즉시 파일/모듈을 쪼갠다.

### **1.1 전역 에러 처리와 예외 추상화**

* 프로젝트는 \*\*공통 에러 모델(커스텀 예외/에러 코드)\*\*을 정의하고 이를 표준으로 사용한다.  
* 필요한 예외/에러 타입은 사용처에서 일관된 방식으로 참조한다(자동/명시 import는 팀 컨벤션으로).  
* 외부 라이브러리/인프라(DB, HTTP 클라이언트 등)의 원본 에러를 그대로 노출하지 않는다.  
* 외부 에러는 **도메인/애플리케이션 에러로 래핑**하고, 사용자에게는 안전한 메시지와 코드만 제공한다.  
* “어디서 어떤 맥락에서 실패했는지”는 내부 로그/모니터링으로 추적 가능해야 한다.

### **1.2 출력(콘솔) 최소화와 로깅 표준화**

* 디버그 목적의 콘솔 출력은 금지(정말 필요한 경우만 예외적으로 허용).  
* 모든 로그는 **표준 로깅 시스템**을 사용한다(언어별 logger/프레임워크 logger).  
* 기본 로깅 포맷/레벨/출력 대상은 프로젝트의 **로깅 설정 파일/모듈**을 따른다.  
* 로그에는 개인정보/민감정보(API 키, 토큰 등)를 남기지 않는다.

### **1.3 이모티콘 사용 금지**

* 코드/로그/문서/주석/커밋 메시지 등 개발 산출물 전반에서 이모티콘을 사용하지 않는다.

### **1.4 타입/스키마 명시(가능한 범위에서)**

* 함수/메서드/클래스/모듈 경계에서 \*\*입출력 타입(또는 스키마/인터페이스)\*\*를 가능한 한 명시한다.  
* 동적 타입 언어라도 DTO/Schema/Interface/Validation을 통해 계약을 만든다.  
* 불가피한 경우를 제외하고 “무제한/모호 타입”(예: Any, object 남발)을 피한다.

### **1.5 주석 스타일**

* 주석은 “왜(WHY)”와 “주의할 점” 중심으로, **핵심 로직에만 최소한** 작성한다.  
* 의도는 주석보다 **함수/변수/타입/모듈 이름**으로 드러내는 것을 우선한다.  
* “이 함수는 \~한다” 같은 반복 설명은 지양한다.  
* **한글 사용 규칙:** 주석만 한글 허용. 그 외(변수/함수/클래스/파일명, 문자열 리터럴, 로그, 에러메시지, docstring 등)는 인코딩 이슈 방지를 위해 영어만 사용.

### **1.6 설정(config)과 환경 변수(env)**

* 환경별/보안 관련 값은 **환경 변수 또는 비밀 관리 시스템**으로 관리한다.  
* 코드에 민감정보(API 키, 비밀번호, 토큰, 내부 주소 등)를 하드코딩하지 않는다.  
* 설정 로딩은 \*\*단일 진입점(Config 모듈/서비스)\*\*에서 수행하고, 다른 곳은 이를 참조한다.

### **1.7 엔트리포인트(실행 진입점) 원칙**

* 엔트리포인트 파일/함수(예: `main`, `app`, `server` 등)는 **부트스트랩만 담당**한다.  
  * 라우팅/핸들러 등록  
  * 예외 처리 미들웨어/필터 등록  
  * 설정 로드  
  * DI/컨테이너 초기화  
* 실제 실행 로직은 별도 모듈/함수/클래스로 분리한다.

### **1.8 네이밍 규칙(언어별 관례 존중)**

* 네이밍은 언어/프레임워크의 관례를 따른다.  
  * 예: 자바/TS는 `camelCase`(변수/함수), `PascalCase`(클래스), 상수는 `UPPER_SNAKE_CASE`  
  * 파이썬은 `snake_case`, `PascalCase`  
* 파일/폴더명도 해당 생태계 관례를 따른다.  
* 중요한 건 “팀 내 일관성”이며, 프로젝트에서 한 번 정하면 유지한다.

### **1.9 의존성 관리**

* 새 라이브러리 추가 시 **의존성 선언 파일**을 반드시 업데이트한다(언어별: package manager lock 포함).  
* 버전은 재현성을 위해 \*\*고정/잠금(lock)\*\*을 사용한다.  
* 불필요한 의존성 추가를 금지하고, 표준 라이브러리/기존 유틸을 우선한다.

---

## **2\) 작성 규칙**

### **2.1 함수/메서드**

* 한 함수는 하나의 책임(SRP).  
* 이름은 **행동(동사) \+ 목적어/대상** 형태로 의도를 명확히 한다.  
  * 예: `loadUserProfile`, `parseInput`, `calculateFee`  
* 로직은 순수하게 유지하고, IO(네트워크/DB/파일)는 경계로 밀어낸다.  
* 입력 검증과 에러 처리는 일관된 방식(공통 에러 모델)으로 한다.

### **2.2 클래스/모듈**

* 하나의 역할(주제)만 담당하도록 설계한다.  
* 데이터의 소유권과 책임 범위를 명확히 한다.  
* 역할이 다르면 분리한다(과도한 만능 유틸/갓 클래스 금지).  
* 외부 의존성은 최소화하고, 필요 시 주입(DI) 또는 어댑터 패턴으로 격리한다.

### **2.3 실행부(흐름 제어)**

* 실행부는 “흐름”만 제어하고, 세부 로직은 함수/클래스/서비스로 분리한다.  
* 테스트 가능한 형태로 구성한다(엔트리포인트가 아닌 곳에서 핵심 로직 테스트 가능).

---

## **3\) Utils 규칙 (언어 공통)**

### **3.1 공통 원칙**

* `utils`는 **프로젝트 전반에서 재사용 가능한 순수한 보조 로직**만 둔다.  
* 인프라(설정/로거/DB/네트워크 등)에 의존하지 않는다.  
* 가능하면 부작용 없는 순수 함수로 작성한다.  
* 중복 로직을 새로 만들기 전에 기존 유틸을 먼저 찾고 재사용한다.

### **3.2 import/사용 규칙**

* 유틸은 출처가 명확하도록 **명시적으로 가져다 쓴다**(언어별 import 방식).  
* 동일 기능이 여러 곳에 생기면 `utils`의 공통 구현을 우선한다.

### **3.3 함수 설계 원칙**

* 단일 기능에 집중하고 다른 레이어(core/features/app)에 의존하지 않는다.  
* 입력 검증, 문자열 처리, 시간/포맷 변환, 간단 계산, 직렬화 같은 보조 역할만 포함한다.  
* 외부 상태(환경 변수), DB, 네트워크 요청 등을 수행하지 않는다.  
* 반환값은 명확하고 예측 가능해야 한다(예: null/예외/Result 타입 중 팀 기준 통일).

### **3.4 파일 구성(예시: 언어 무관한 카테고리)**

* `string_utils` : 문자열 변환/정규화/ID 생성  
* `time_utils` : 시간 생성/포맷/차이 계산  
* `validation_utils` : 입력값 검증(이메일/전화번호 등)  
* `hash_utils` : 해시/서명/토큰 생성 및 비교(보안 정책 준수)  
* `file_utils` : 파일/폴더 처리(단, “순수함수” 원칙과 충돌하면 별도 레이어로 분리)  
* `json_utils` : 직렬화/역직렬화/안전 변환  
* `env_utils` : 환경 변수 접근은 가능하지만, “utils는 인프라 의존 금지” 원칙과 충돌하므로 보통 **config 레이어로 이동**을 권장  
* `math_utils` : 간단 계산/반올림/비율

---

 